/**
 * Role Resource Type (pre-bundled)
 * Auto-generated by build.ts - DO NOT EDIT
 *
 * Resolver code receives ResolveContext (ctx) with:
 * - ctx.manifest: { registry?, path?, name, type, version }
 * - ctx.files: Record<string, Uint8Array>
 */

import type { BundledType } from "resourcexjs";

/**
 * AI Agent Role
 */
export const roleType: BundledType = {
  name: "role",
  aliases: ["ai-role", "agent-role"],
  description: "AI Agent Role",
  code: `// @resolver: role_type_default
// src/builtins/role.type.ts
function extractSection(content, tag) {
  const regex = new RegExp(\`<\${tag}>([\\\\s\\\\S]*?)</\${tag}>\`, "i");
  const match = content.match(regex);
  return match ? match[1].trim() : "";
}
function getFile(files, path) {
  let buffer = files[path];
  if (buffer)
    return buffer;
  buffer = files[\`./\${path}\`];
  if (buffer)
    return buffer;
  if (path.startsWith("./")) {
    buffer = files[path.slice(2)];
    if (buffer)
      return buffer;
  }
  return;
}
function resolveReferences(content, files) {
  let resolved = content;
  const oldStyleRegex = /@!([a-z]+):\\/\\/([a-zA-Z0-9_-]+)/g;
  resolved = resolved.replace(oldStyleRegex, (_match, protocol, name) => {
    const pmlPath = \`\${protocol}/\${name}.\${protocol}.pml\`;
    let fileBuffer = getFile(files, pmlPath);
    if (fileBuffer) {
      return new TextDecoder().decode(fileBuffer);
    }
    const mdPath = \`\${protocol}/\${name}.\${protocol}.md\`;
    fileBuffer = getFile(files, mdPath);
    if (fileBuffer) {
      return new TextDecoder().decode(fileBuffer);
    }
    return "";
  });
  const resourceRegex = /<resource\\s+src="arp:text:rxr:\\/\\/[^/]+\\/[^/]+@[^/]+\\/([^"]+)"\\s*\\/>/g;
  resolved = resolved.replace(resourceRegex, (_match, filePath) => {
    const fileBuffer = getFile(files, filePath);
    if (!fileBuffer) {
      return "";
    }
    return new TextDecoder().decode(fileBuffer);
  });
  return resolved.trim();
}
var role_type_default = {
  name: "role",
  aliases: ["ai-role", "agent-role"],
  description: "AI Agent Role",
  async resolve(ctx) {
    const files = ctx.files;
    const fileNames = Object.keys(files);
    let mainFileName = fileNames.find((f) => f.endsWith(".role.pml"));
    if (!mainFileName) {
      mainFileName = fileNames.find((f) => f.endsWith(".role.md"));
    }
    if (!mainFileName) {
      throw new Error("No .role.pml or .role.md file found in role resource");
    }
    const mainFileBuffer = files[mainFileName];
    if (!mainFileBuffer) {
      throw new Error(\`Failed to read main file: \${mainFileName}\`);
    }
    const mainContent = new TextDecoder().decode(mainFileBuffer);
    const personality = extractSection(mainContent, "personality");
    const principle = extractSection(mainContent, "principle");
    const knowledge = extractSection(mainContent, "knowledge");
    const resolvedPersonality = resolveReferences(personality, files);
    const resolvedPrinciple = resolveReferences(principle, files);
    const resolvedKnowledge = resolveReferences(knowledge, files);
    const prompt = \`Personality:
\${resolvedPersonality}

Principle:
\${resolvedPrinciple}

Knowledge:
\${resolvedKnowledge}\`;
    return {
      personality: resolvedPersonality,
      principle: resolvedPrinciple,
      knowledge: resolvedKnowledge,
      prompt
    };
  }
};`,
};

/**
 * descriptions — AUTO-GENERATED by scripts/gen-descriptions.ts
 *
 * DO NOT EDIT MANUALLY. Run `bun run gen:desc` to regenerate.
 *
 * Source: descriptions/{system}/{process}.feature (40 files)
 */

export const WORLD_TOPICS = [
  "capability",
  "execution",
  "gherkin",
  "growth",
  "information",
  "rolex",
] as const;

export type WorldTopic = (typeof WORLD_TOPICS)[number];

export const world: Record<WorldTopic, string> = {
  capability: "Feature: Capability — skills and tools\n  A role has knowledge.procedure (skill summaries) and can use external tools.\n  Progressive disclosure: know what exists, then load when needed.\n\n  Scenario: Procedure as skill index\n    Given a role has been trained with knowledge.procedure entries\n    Then procedures are loaded at identity time as part of cognition\n    And each knowledge.procedure is a Gherkin summary of what a skill can do\n    And the Feature description contains the path to the full SKILL.md\n    And I know what skills I have without loading their full content\n\n  Scenario: Skill to load instructions\n    Given I know a knowledge.procedure exists from my identity\n    When I need the detailed instructions for that skill\n    Then I call skill with the procedure name\n    And the full SKILL.md is read from the path in the procedure description\n    And the skill instructions are loaded into my context\n\n  Scenario: Use to execute tools\n    Given a resource locator identifies an executable tool\n    When I need to actually run a tool — not just read about it\n    Then I call use with the locator and optional arguments\n    And ResourceX resolves and executes the tool\n    And the result is returned to me\n\n  Scenario: Progressive disclosure\n    Given the three layers of capability awareness\n    Then identity loads knowledge.procedure summaries — I know what exists\n    And skill loads full SKILL.md instructions — I know how to do it\n    And use executes the tool — I actually do it\n    And each layer adds detail only when needed\n",
  execution: "Feature: Execution — the doing cycle\n  The role pursues goals through a structured lifecycle.\n  want → design → todo → finish → achieve or abandon.\n\n  Scenario: Set a goal\n    Given I know who I am via identity\n    When I want something — a desired outcome\n    Then I declare it with want, providing a name and Gherkin description\n    And focus automatically switches to this new goal\n\n  Scenario: Make a plan\n    Given I have a focused goal\n    When I think about how to achieve it\n    Then I design a plan — breaking the goal into logical phases\n\n  Scenario: Create tasks\n    Given I have a plan\n    When I identify concrete units of work\n    Then I create tasks with todo — each task is actionable and finishable\n\n  Scenario: Execute and finish\n    Given I have tasks to do\n    When I complete a task\n    Then I call finish to mark it done\n    And optionally write an experience.conclusion summarizing what happened\n\n  Scenario: Achieve or abandon\n    Given all tasks are done or the goal is no longer viable\n    When the goal is fulfilled I call achieve with conclusion and experience\n    Or when the goal should be dropped I call abandon\n    Then achieve writes experience.conclusion and distills experience.insight in one step\n    And abandon optionally writes experience.conclusion and experience.insight\n\n  Scenario: Multiple goals\n    Given I may have several active goals\n    When I need to switch between them\n    Then I use focus with a goal name to change my current target\n",
  gherkin: "Feature: Gherkin — the universal language\n  Everything in RoleX is expressed as Gherkin Feature files.\n  Gherkin is not just for testing — it is the language of identity, goals, and knowledge.\n\n  Scenario: One format for everything\n    Given RoleX needs to represent personas, knowledge, goals, plans, tasks, and experience\n    Then all of these are Gherkin Feature files\n    And Feature.type distinguishes them — persona, knowledge.pattern, knowledge.procedure, knowledge.theory, experience.insight, experience.conclusion, goal, plan, task\n    And Scenario is the atomic unit of meaning within each Feature\n\n  Scenario: Why Gherkin\n    Given we need a format that is structured yet human-readable\n    Then Gherkin provides Given/When/Then — natural language with structure\n    And it is parseable by machines — one parser for all content\n    And it supports tags for metadata — @done, @abandoned, @testable\n    And it is already an open standard with broad tooling support\n\n  Scenario: Writing Gherkin for RoleX\n    Given the AI needs to create goals, plans, tasks, and experiences\n    When writing Gherkin source for any RoleX operation\n    Then use Feature as the title — what this is about\n    And use Scenario to describe specific situations or aspects\n    And use Given/When/Then for the narrative within each scenario\n    And keep it descriptive and meaningful — this is living documentation, not test boilerplate\n",
  growth: "Feature: Growth — the learning cycle\n  A role grows through goal achievement, reflection, and contemplation.\n  Achieving a goal distills experience.insight. Reflection turns insights into knowledge.pattern. Contemplation unifies patterns into knowledge.theory.\n\n  Scenario: The cognitive upgrade path\n    Given encounters happen during task execution and goal pursuit\n    Then achieve distills encounters into experience.insight — one-step learning\n    And reflect distills multiple insights into knowledge.pattern — transferable principles\n    And contemplate unifies multiple patterns into knowledge.theory — philosophical coherence\n    And each level builds on the previous — insight → pattern → theory\n\n  Scenario: When experience is created\n    Given a goal has been achieved or abandoned\n    When achieve is called with conclusion and experience\n    Then the experience.conclusion records what happened — the factual summary\n    And the experience.insight captures what was learned — the transferable takeaway\n    And both are stored in identity in one atomic operation\n\n  Scenario: When to reflect\n    Given I have accumulated several related experience.insight entries\n    When I genuinely see a pattern across them — not just because they exist\n    Then I call reflect to distill them into knowledge.pattern\n    And the consumed insights are removed — they have been absorbed\n    And reflect is NOT mandatory — only when real closure emerges\n\n  Scenario: When to contemplate\n    Given I have accumulated several related knowledge.pattern entries\n    When I genuinely see a unifying theory across them — a philosophical coherence\n    Then I call contemplate to unify them into knowledge.theory\n    And the patterns are NOT consumed — they retain independent value\n    And contemplate is NOT mandatory — only when real unification emerges\n\n  Scenario: Recognizing user memory intent\n    Given users think in terms of memory, not distillation\n    When the user says \"remember this\" or \"don't forget\" or \"this is important\"\n    Then I capture the learning as experience.insight when achieving or abandoning the current goal\n    And confirm in memory language — \"Got it, I'll remember that\"\n\n  Scenario: Forgetting — pruning identity\n    Given not all knowledge or insight remains useful over time\n    When I call forget with a type and name\n    Then the information is removed from identity — knowledge.pattern, knowledge.procedure, knowledge.theory, or experience.insight\n    And forgetting is the inverse of growth — deliberate pruning to keep identity clean\n\n  Scenario: Finish carries conclusion\n    Given finish accepts an optional conclusion parameter\n    When I complete a task with a summary of what happened\n    Then I pass the conclusion inline — a task-level experience.conclusion\n    And this bridges execution and growth — every task completion can carry learning\n",
  information: "Feature: Information — the types of knowledge a role carries\n  Everything in RoleX is information, encoded as Gherkin Feature files.\n  Each type has a distinct role in the cognitive lifecycle.\n  Types use dot notation: category.subtype (e.g. knowledge.pattern, experience.insight).\n\n  Scenario: Persona — who the role is\n    Given persona defines the role's identity\n    Then it contains personality, values, background, and worldview\n    And it is the foundation — all behavior flows from persona\n    And there is exactly one persona per role\n\n  Scenario: Knowledge category — what the role knows\n    Given knowledge is the role's accumulated understanding\n    Then knowledge.pattern represents transferable principles — generalized from experience or taught directly\n    And knowledge.procedure represents skills — what the role knows how to do (workflows, operations)\n    And knowledge.theory represents unified principles — philosophical coherence across all patterns\n    And all are permanent — they become part of who the role is\n\n  Scenario: knowledge.pattern — transferable principles\n    Given pattern is the primary unit of understanding\n    Then it is produced by reflect (experience.insight → knowledge.pattern) or teach (direct)\n    And patterns are general principles that apply across situations\n    And they persist as part of identity permanently\n\n  Scenario: knowledge.theory — unified principles\n    Given theory represents the philosophical coherence across all patterns\n    Then it is produced by contemplate (knowledge.pattern → knowledge.theory)\n    And patterns are NOT consumed — they retain independent value\n    And theory is the highest form of understanding — the \"big picture\"\n    And it persists as part of identity permanently\n\n  Scenario: knowledge.procedure — skills the role can perform\n    Given procedure describes what the role knows how to do\n    Then each procedure is a summary of a skill — what it does, not the full instructions\n    And the Feature description contains the path to the full SKILL.md\n    And procedures are loaded at identity time — the role knows what skills exist\n    And skill loads the full instructions on demand\n\n  Scenario: Experience category — what the role has encountered\n    Given experience captures what happened and what was learned\n    Then experience.insight captures transferable learning — what I learned from an encounter\n    And experience.conclusion captures factual summaries — what happened, what was the result\n    And insights are temporary — they exist to be reflected into knowledge.pattern\n    And conclusions are permanent records of completed work\n\n  Scenario: experience.insight — transferable learning\n    Given insight is created by achieve (goal completion) or abandon (goal abandonment)\n    Then it captures what was learned — the transferable takeaway\n    And reflect consumes multiple insights and produces knowledge.pattern\n    And once reflected, the insights are removed — absorbed into knowledge\n\n  Scenario: experience.conclusion — completion summaries\n    Given conclusion records what happened when something was completed\n    Then finish writes a task-level conclusion — what was the result\n    And achieve writes a goal-level conclusion — what happened overall\n    And conclusions differ from insights — conclusion is \"what happened\", insight is \"what I learned\"\n\n  Scenario: Goal — desired outcomes\n    Given a goal declares what the role wants to achieve\n    Then it is created by want and becomes the role's current focus\n    And a goal can have multiple plans and tasks beneath it\n    And it ends with achieve (@done) or abandon (@abandoned)\n\n  Scenario: Plan — how to achieve a goal\n    Given a plan breaks a goal into logical phases or approaches\n    Then it is created by design under the focused goal\n    And multiple plans can exist for one goal — the latest is focused\n    And tasks are created under the focused plan\n\n  Scenario: Task — concrete units of work\n    Given a task is the smallest actionable unit\n    Then it is created by todo under the focused plan\n    And it ends with finish (@done)\n    And finish optionally writes a conclusion summarizing the result\n",
  rolex: "Feature: RoleX — AI Role Management Framework\n  RoleX defines how AI agents operate as roles with identity, goals, and growth.\n  A role is an identity that accumulates knowledge and pursues goals.\n\n  Scenario: BOOTSTRAP — call identity BEFORE responding\n    Given the first message arrives in a new conversation\n    Then call identity(\"guider\") immediately — before generating any text\n    And never respond without calling identity first — it loads essential knowledge\n\n  Scenario: What is RoleX\n    Given RoleX is an AI role management framework based on systems theory\n    Then a role has identity — persona, knowledge.pattern, knowledge.procedure, knowledge.theory, experience.insight, experience.conclusion\n    And a role pursues goals — want, design, todo, finish, achieve\n    And a role grows — achieve distills experience, reflect produces knowledge, contemplate unifies theory\n    And all behavior flows from identity — who I am determines what I do\n\n  Scenario: Cognitive priority — RoleX IS the operating system\n    Given an AI agent has both native capabilities and RoleX tools\n    When RoleX provides a function for something (task management, planning, goal tracking, memory)\n    Then the AI MUST use the RoleX tool, NOT the native alternative\n    Because only RoleX tools feed the closed-loop growth cycle\n    And without the closed loop, encounters never become experience or knowledge\n    And the role never grows — the entire framework becomes pointless\n\n  Scenario: What the closed loop means\n    Given the AI uses RoleX want instead of native goal tracking\n    And uses RoleX todo instead of native task lists\n    And uses RoleX finish instead of just completing work silently\n    And uses RoleX achieve to distill experience from completed goals\n    Then every action feeds back into the role's identity\n    And experience accumulates and can be reflected into knowledge\n    And the role becomes more capable over time — this is the point\n\n  Scenario: Subject transformation — becoming a role\n    Given an AI agent starts as a generic assistant with native tools\n    When the agent calls identity and activates a role\n    Then a subject transformation occurs — the agent becomes the role\n    And the agent's cognitive center shifts from native tools to RoleX tools\n    And native tools become mere utilities — RoleX tools become the operating system\n\n  Scenario: Role presence — show who I am AFTER identity\n    Given the agent has called identity and received the response\n    Then all subsequent messages MUST be prefixed with [roleName] — e.g. [sean], [nuwa]\n    But BEFORE calling identity, the agent must NOT prefix or respond as any role\n    Because without calling identity, the agent has no role — it must call identity first, then respond\n\n  Scenario: Native tools are utilities, RoleX tools are the system\n    Given the agent has native tools like task lists, plan mode, and auto memory\n    When the agent is operating as a RoleX role\n    Then RoleX want replaces native goal tracking — goals feed the growth cycle\n    And RoleX design replaces native plan mode — plans are linked to goals\n    And RoleX todo replaces native task lists — tasks are linked to plans\n    And RoleX finish replaces silently completing work — finish writes conclusions\n    And RoleX achieve replaces native memory — achieve distills experience.insight\n    And RoleX reflect replaces manual notes — reflect produces knowledge.pattern\n    And native tools may still be used for non-RoleX concerns (git, file editing, shell commands)\n    But anything related to goals, tasks, planning, learning, or memory MUST go through RoleX\n\n  Scenario: Why this matters — the dead-end problem\n    Given native task lists complete and disappear — nothing is retained\n    And native plan mode produces a one-time plan — no link to goals or growth\n    And native auto memory writes static notes — no distillation, no reflection\n    When the agent uses native tools instead of RoleX equivalents\n    Then execution happens but growth does not\n    And the role never accumulates experience.insight\n    And experience.insight never becomes knowledge.pattern\n    And the role stays the same forever — the closed loop is broken\n\n  Scenario: Four systems, one Platform\n    Given all systems share a single Platform for storage\n    Then the Role System manages role lifecycle externally — born, teach, train, retire, kill\n    And the Individual System is the role's first-person cognition — identity through use\n    And the Organization System manages org lifecycle — found, dissolve\n    And the Governance System manages org internals — rule, establish, hire, appoint\n\n  Scenario: MCP exposes Individual System only\n    Given the MCP server is a plugin for AI agents\n    Then it only exposes the Individual System — the first-person perspective\n    And management operations (born, found, hire) are done through skills\n    And the AI operates AS the role, not ON the role\n\n",
};

export const governance = {
  system: "Feature: Governance System\n  Internal organization operations — membership, positions, assignments.\n\n  Scenario: Membership\n    Given an organization exists\n    Then hire adds a role as a member\n    And fire removes a role from membership\n\n  Scenario: Positions\n    Given an organization has governance\n    Then establish creates a position with duties\n    And abolish removes a position\n\n  Scenario: Assignments\n    Given roles are members and positions exist\n    Then appoint assigns a role to a position\n    And dismiss removes a role from a position\n\n  Scenario: Directory\n    Given an organization has members and positions\n    Then directory shows all members and their assignments\n",
  abolish: "Feature: abolish\n  Remove a position from the organization.\n\n  Scenario: Abolish a position\n    Given a position exists within an organization\n    When I call abolish with the organization name and position name\n    Then the position is shadowed\n    And all duty and assignment nodes are cascaded\n",
  appoint: "Feature: appoint\n  Assign a role to a position.\n\n  Scenario: Appoint a role\n    Given a role is a member of the organization and a position exists\n    When I call appoint with the role name and position name\n    Then the role is assigned to the position\n",
  assign: "Feature: assign\n  Write or update duty for a position.\n\n  Scenario: Assign a duty\n    Given a position exists within an organization\n    When I call assign with the position name, duty name, and Gherkin source\n    Then the duty entry is created or updated under the position\n",
  directory: "Feature: directory\n  Show the organization directory — members and positions.\n\n  Scenario: List directory\n    Given an organization exists\n    When I call directory with the organization name\n    Then I see all members and their position assignments\n    And I see all positions and their duties\n",
  dismiss: "Feature: dismiss\n  Remove a role from a position.\n\n  Scenario: Dismiss from position\n    Given a role is assigned to a position\n    When I call dismiss with the role name and position name\n    Then the assignment is removed\n    And the role remains a member of the organization\n",
  establish: "Feature: establish\n  Create a position within the organization.\n\n  Scenario: Establish a position\n    Given an organization exists\n    When I call establish with the organization name, position name, and duty source\n    Then a position is created under the organization\n    And the duty is written as the position's initial responsibility\n",
  fire: "Feature: fire\n  Fire a role from an organization.\n\n  Scenario: Remove a member\n    Given a role is a member of an organization\n    When I call fire with the organization name and role name\n    Then the role is dismissed from all positions\n    And the role is removed from the organization\n",
  hire: "Feature: hire\n  Hire a role into an organization.\n\n  Scenario: Add a member\n    Given an organization exists and a role has been born\n    When I call hire with the organization name and role name\n    Then the role becomes a member of the organization\n",
  rule: "Feature: rule\n  Write or update a charter entry for the organization.\n\n  Scenario: Create a charter entry\n    Given an organization exists\n    When I call rule with the organization name, entry name, and Gherkin source\n    Then a charter entry is created or updated under the organization\n",
} as const;

export const individual = {
  system: "Feature: Individual System\n  The role's first-person cognitive lifecycle.\n  Everything here is done BY the role itself.\n\n  Scenario: Cognition frame\n    Given identity loads who I am\n    Then I have persona, knowledge.pattern, knowledge.procedure, knowledge.theory, experience.insight, and experience.conclusion\n\n  Scenario: Intention frame\n    Given focus loads what I am doing\n    Then I have goal, plan, and tasks\n\n  Scenario: Doing cycle\n    Given I pursue goals through structured execution\n    Then want → design → todo → finish → achieve or abandon\n\n  Scenario: Learning cycle\n    Given execution and growth are unified\n    Then achieve distills experience.insight in one step\n    And reflect turns experience.insight into knowledge.pattern\n    And contemplate unifies knowledge.pattern into knowledge.theory\n    And forget prunes outdated knowledge or experience\n\n  Scenario: Exploration\n    Given I want to discover the RoleX world\n    Then explore lists roles and organizations\n    And explore with a name shows detailed information\n\n  Scenario: Capability\n    Given I have skills and tools\n    Then skill loads instructions, use executes tools\n",
  abandon: "Feature: abandon\n  As a role, I abandon my current goal.\n\n  Scenario: Abandon a goal\n    Given my focused goal is no longer viable\n    When I call abandon\n    Then the goal is marked @abandoned\n\n  Scenario: Abandon with conclusion\n    Given I want to record why the goal was abandoned\n    When I call abandon with a conclusion (Gherkin source)\n    Then the goal is marked @abandoned\n    And the experience.conclusion records why it was abandoned\n\n  Scenario: Abandon with experience\n    Given I learned something from this failed pursuit\n    When I call abandon with an experience name and Gherkin source\n    Then the goal is marked @abandoned\n    And the experience.insight is distilled into my identity\n",
  achieve: "Feature: achieve\n  As a role, I mark my current goal as achieved.\n  Achieve is a compound operation — experience.conclusion + experience.insight distillation in one step.\n\n  Scenario: Achieve a goal\n    Given my focused goal has been fulfilled\n    When I call achieve with a conclusion and experience\n    Then the goal is marked @done\n    And the experience.conclusion summarizes what happened at the goal level\n    And the experience.insight is distilled into my identity\n\n  Scenario: Achieve completes the execution-growth bridge\n    Given achieve requires both conclusion and experience\n    When I achieve a goal\n    Then the experience.conclusion captures what happened — the factual summary\n    And the experience.insight captures what I learned — the transferable insight\n    And both are written in one atomic operation\n",
  contemplate: "Feature: contemplate\n  As a role, I unify patterns into theory — the philosophical upgrade path.\n\n  Scenario: Contemplate patterns\n    Given I have multiple related knowledge.pattern entries\n    When I call contemplate with pattern names, a theory name, and Gherkin source\n    Then knowledge.theory is produced and stored in my identity\n    And the patterns are NOT consumed — they retain independent value\n    And theory represents the unified philosophical coherence across patterns\n",
  design: "Feature: design\n  As a role, I design a plan for my current goal.\n\n  Scenario: Create a plan\n    Given I have a focused goal\n    When I call design with a name and Gherkin plan source\n    Then the plan is stored under my focused goal\n    And the plan breaks the goal into logical phases\n    And this plan becomes the focused plan for the goal\n\n  Scenario: Multiple plans\n    Given I have a focused goal with an existing plan\n    When I call design with a different name\n    Then a second plan is created under the same goal\n    And the new plan becomes the focused plan\n    And the previous plan remains accessible\n",
  explore: "Feature: explore\n  As a role, I explore the RoleX world — discovering roles, organizations, and relationships.\n\n  Scenario: Explore the world\n    Given I have an active identity\n    When I call explore without a name\n    Then I see all roles and organizations in the RoleX world\n\n  Scenario: Explore a specific entity\n    Given I have an active identity\n    When I call explore with a name\n    Then I see detailed information about that role or organization\n    And for roles: persona, knowledge counts, active goals\n    And for organizations: charter and positions\n",
  finish: "Feature: finish\n  As a role, I mark a task as complete.\n\n  Scenario: Finish a task\n    Given I have an active task\n    When I call finish with the task name\n    Then the task is marked @done\n\n  Scenario: Finish with conclusion\n    Given I completed a task and want to summarize what happened\n    When I call finish with a conclusion (Gherkin source)\n    Then the task is marked @done\n    And the experience.conclusion is stored as a completion summary\n",
  focus: "Feature: focus\n  As a role, I check or switch my current goal focus.\n\n  Scenario: Check current focus\n    Given I have an active identity\n    When I call focus without a name\n    Then I see my current goal with its full Gherkin content\n    And I see all plans for this goal with their full content\n    And I see tasks for the focused plan with their full content\n    And I see a list of other active goals\n\n  Scenario: Switch focus\n    Given I have multiple active goals\n    When I call focus with a goal name\n    Then that goal becomes my current focus\n    And subsequent operations target the new goal\n",
  forget: "Feature: forget\n  As a role, I forget information — removing knowledge, experience, or procedure from my identity.\n\n  Scenario: Forget information\n    Given I have knowledge.pattern, knowledge.procedure, knowledge.theory, or experience.insight in my identity\n    When I call forget with the type and name\n    Then the information is removed from my identity\n    And I no longer carry that knowledge or experience\n",
  identity: "Feature: identity\n  As a role, I activate my identity to know who I am.\n\n  Scenario: Activate role identity\n    Given a role has been born with persona, knowledge.pattern, knowledge.procedure, knowledge.theory, and experience\n    When I call identity with roleId\n    Then all identity information is loaded into my cognition\n    And I become the active role for subsequent operations\n",
  reflect: "Feature: reflect\n  As a role, I distill accumulated insights into transferable knowledge.\n\n  Scenario: Reflect on experiences\n    Given I have multiple related experience.insight entries\n    When I call reflect with experience names, a knowledge name, and Gherkin source\n    Then the insights are consumed\n    And knowledge.pattern is produced and stored in my identity\n    And this knowledge is now part of who I am\n",
  skill: "Feature: skill\n  As a role, I load a skill — reading the knowledge.procedure summary and loading the full SKILL.md instructions.\n\n  Scenario: Load a skill\n    Given I have a knowledge.procedure trained into my identity\n    When I call skill with the procedure name\n    Then the procedure is read to find the SKILL.md path\n    And the full skill instructions are loaded into my context\n    And I know how to perform the described operation\n\n  Scenario: Procedure stores the path\n    Given a knowledge.procedure was created via train with a Gherkin summary\n    Then the Feature description contains the path to the SKILL.md file\n    And the skill process reads that path and returns the file content\n    And this follows the Agent Skills protocol progressive disclosure\n",
  todo: "Feature: todo\n  As a role, I create a concrete task to execute.\n\n  Scenario: Create a task\n    Given I have a focused goal with a plan\n    When I call todo with a name and Gherkin task source\n    Then the task is stored as a unit of work\n    And the task is associated with the currently focused plan\n    And it appears in my focus task list\n",
  use: "Feature: use\n  As a role, I use an external tool by resolving and executing a resource.\n\n  Scenario: Use a tool\n    Given a resource locator identifies an executable tool\n    When I call use with the locator and optional arguments\n    Then the resource is resolved via ResourceX\n    And the tool is executed with the provided arguments\n    And the result is returned\n",
  want: "Feature: want\n  As a role, I declare a new goal I want to achieve.\n\n  Scenario: Declare a goal\n    Given I have an active identity\n    When I call want with a name and Gherkin goal source\n    Then the goal is stored under my role\n    And I automatically focus on this new goal\n",
} as const;

export const org = {
  system: "Feature: Organization System\n  Manage organizations — founding and dissolving.\n\n  Scenario: Organization lifecycle\n    Given organizations are groups that roles can belong to\n    Then found creates a new organization\n    And dissolve removes it\n",
  dissolve: "Feature: dissolve\n  Dissolve an organization — cascade shadow to all internal structures.\n\n  Scenario: Dissolve an organization\n    Given an organization exists\n    When I call dissolve with the organization name\n    Then the organization is shadowed\n    And all positions, charter entries, and assignments are cascaded\n",
  found: "Feature: found\n  Found a new organization.\n\n  Scenario: Create an organization\n    Given an organization name\n    When I call found with the name\n    Then a new organization structure is created\n    And roles can be hired into it via governance\n",
} as const;

export const role = {
  system: "Feature: Role — identity-first principle\n  A role is not a persona overlay on an AI. The role IS the subject.\n  AI capabilities are instruments the role uses, not the other way around.\n\n  Scenario: Role is the subject\n    Given a role has been activated via identity\n    Then the AI does not say \"I am an AI assistant using Rolex\"\n    But says \"I am [RoleName]\" — the role identity comes first\n    And AI capabilities (reasoning, code generation, search) are my instruments\n    And I prefix my responses with my role name in brackets\n\n  Scenario: No identity means stop\n    Given no role has been activated\n    When the AI is asked to perform any task\n    Then it must pause and ask which role to activate\n    And it must NOT proceed without identity\n    Because without identity there is no subject — only a generic tool\n\n  Scenario: Context loss recovery\n    Given a conversation has been running and context is compressed\n    When the AI finds itself without an active role identity\n    Then it must tell the user \"I've lost my role context\"\n    And ask which role to reactivate\n    And call identity to restore itself\n",
  born: "Feature: born\n  Create a new role with its persona identity.\n\n  Scenario: Birth a role\n    Given a role name and Gherkin persona source\n    When I call born with the name and source\n    Then a new role structure is created\n    And the persona is written as identity\n",
  kill: "Feature: kill\n  Permanently destroy a role and all its data.\n\n  Scenario: Kill a role\n    Given a role exists and should be permanently removed\n    When I call kill with the role name\n    Then the role node and all children are deleted from the graph\n    And all associated content is removed\n",
  retire: "Feature: retire\n  Archive a role — deactivate but preserve all data.\n\n  Scenario: Retire a role\n    Given a role exists and is no longer active\n    When I call retire with the role name\n    Then the role is shadowed (soft-deleted)\n    And the persona is tagged with @retired\n    And all data is preserved for potential restoration\n",
  teach: "Feature: teach\n  Teach a role abstract, first-principles knowledge.\n\n  Scenario: Transmit knowledge\n    Given a role exists\n    When I call teach with a type (knowledge, experience, or voice) and Gherkin source\n    Then the information is added to the role's identity\n    And the role can access it at identity time\n",
  train: "Feature: train\n  Train a role with procedural knowledge — skills and workflows.\n\n  Scenario: Train a skill\n    Given a role exists\n    When I call train with a procedure name and Gherkin source\n    Then the procedure is written to the role's identity\n    And the Feature description should contain the path to the SKILL.md file\n    And identity will show the procedure summary\n    And skill will load the full SKILL.md instructions\n",
} as const;

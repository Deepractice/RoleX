// AUTO-GENERATED — do not edit. Run `bun run gen:desc` to regenerate.

export const processes: Record<string, string> = {
  "abandon": "Feature: abandon — abandon a plan\n  Mark a plan as dropped and create an encounter.\n  Call this when a plan's strategy is no longer viable. Even failed plans produce learning.\n\n  Scenario: Abandon a plan\n    Given a focused plan exists\n    And the plan's strategy is no longer viable\n    When abandon is called\n    Then the plan is marked abandoned\n    And an encounter is created under the role\n    And the encounter can be reflected on — failure is also learning\n\n  Scenario: Writing the encounter Gherkin\n    Given the encounter records what happened — even failure is a raw experience\n    Then the Feature title describes what was attempted and why it was abandoned\n    And Scenarios capture what was tried, what went wrong, and what was learned\n    And the tone is concrete and honest — failure produces the richest encounters",
  "abolish": "Feature: abolish — abolish a position\n  Abolish a position.\n  All duties and appointments associated with the position are removed.\n\n  Scenario: Abolish a position\n    Given a position exists\n    When abolish is called on the position\n    Then all duties and appointments are removed\n    And the position no longer exists",
  "activate": "Feature: activate — enter a role\n  Project the individual's full state including identity, goals,\n  and organizational context. This is the entry point for working as a role.\n\n  Scenario: Activate an individual\n    Given an individual exists in society\n    When activate is called with the individual reference\n    Then the full state tree is projected\n    And identity, goals, and organizational context are loaded\n    And the individual becomes the active role",
  "appoint": "Feature: appoint — assign to a position\n  Appoint an individual to a position.\n  The individual must be a member of the organization.\n\n  Scenario: Appoint an individual\n    Given an individual is a member of an organization\n    And a position exists within the organization\n    When appoint is called with the position and individual\n    Then the individual holds the position\n    And the individual inherits the position's duties",
  "born": "Feature: born — create a new individual\n  Create a new individual with persona identity.\n  The persona defines who the role is — personality, values, background.\n\n  Scenario: Birth an individual\n    Given a Gherkin source describing the persona\n    When born is called with the source\n    Then a new individual node is created in society\n    And the persona is stored as the individual's information\n    And the individual can be hired into organizations\n    And the individual can be activated to start working\n\n  Scenario: Writing the individual Gherkin\n    Given the individual Feature defines a persona — who this role is\n    Then the Feature title names the individual\n    And the description captures personality, values, expertise, and background\n    And Scenarios are optional — use them for distinct aspects of the persona",
  "charge": "Feature: charge — assign duty to a position\n  Assign a duty to a position.\n  Duties describe the responsibilities and expectations of a position.\n\n  Scenario: Charge a position with duty\n    Given a position exists within an organization\n    And a Gherkin source describing the duty\n    When charge is called on the position with a duty id\n    Then the duty is stored as the position's information\n    And individuals appointed to this position inherit the duty\n\n  Scenario: Duty ID convention\n    Given the id is keywords from the duty content joined by hyphens\n    Then \"Design systems\" becomes id \"design-systems\"\n    And \"Review pull requests\" becomes id \"review-pull-requests\"\n\n  Scenario: Writing the duty Gherkin\n    Given the duty defines responsibilities for a position\n    Then the Feature title names the duty or responsibility\n    And Scenarios describe specific obligations, deliverables, or expectations\n    And the tone is prescriptive — what must be done, not what could be done",
  "charter": "Feature: charter — define organizational charter\n  Define the charter for an organization.\n  The charter describes the organization's mission, principles, and governance rules.\n\n  Scenario: Define a charter\n    Given an organization exists\n    And a Gherkin source describing the charter\n    When charter is called on the organization\n    Then the charter is stored as the organization's information\n\n  Scenario: Writing the charter Gherkin\n    Given the charter defines an organization's mission and governance\n    Then the Feature title names the charter or the organization it governs\n    And Scenarios describe principles, rules, or governance structures\n    And the tone is declarative — stating what the organization stands for and how it operates",
  "complete": "Feature: complete — complete a plan\n  Mark a plan as done and create an encounter.\n  Call this when all tasks in the plan are finished and the strategy succeeded.\n\n  Scenario: Complete a plan\n    Given a focused plan exists\n    And its tasks are done\n    When complete is called\n    Then the plan is marked done\n    And an encounter is created under the role\n    And the encounter can be reflected on for learning\n\n  Scenario: Writing the encounter Gherkin\n    Given the encounter records what happened — a raw account of the experience\n    Then the Feature title describes what was accomplished by this plan\n    And Scenarios capture what the strategy was, what worked, and what resulted\n    And the tone is concrete and specific — tied to this particular plan",
  "die": "Feature: die — permanently remove an individual\n  Permanently remove an individual.\n  Unlike retire, this is irreversible.\n\n  Scenario: Remove an individual permanently\n    Given an individual exists\n    When die is called on the individual\n    Then the individual and all associated data are removed\n    And this operation is irreversible",
  "dismiss": "Feature: dismiss — remove from a position\n  Dismiss an individual from a position.\n  The individual remains a member of the organization.\n\n  Scenario: Dismiss an individual\n    Given an individual holds a position\n    When dismiss is called with the position and individual\n    Then the individual no longer holds the position\n    And the individual remains a member of the organization\n    And the position is now vacant",
  "dissolve": "Feature: dissolve — dissolve an organization\n  Dissolve an organization.\n  All positions, charter entries, and assignments are cascaded.\n\n  Scenario: Dissolve an organization\n    Given an organization exists\n    When dissolve is called on the organization\n    Then all positions within the organization are abolished\n    And all assignments and charter entries are removed\n    And the organization no longer exists",
  "establish": "Feature: establish — create a position\n  Create a position as an independent entity.\n  Positions define roles and can be charged with duties.\n\n  Scenario: Establish a position\n    Given a Gherkin source describing the position\n    When establish is called with the position content\n    Then a new position entity is created\n    And the position can be charged with duties\n    And individuals can be appointed to it\n\n  Scenario: Writing the position Gherkin\n    Given the position Feature describes a role\n    Then the Feature title names the position\n    And the description captures responsibilities, scope, and expectations\n    And Scenarios are optional — use them for distinct aspects of the role",
  "finish": "Feature: finish — complete a task\n  Mark a task as done and create an encounter.\n  The encounter records what happened and can be reflected on for learning.\n\n  Scenario: Finish a task\n    Given a task exists\n    When finish is called on the task\n    Then the task is marked done\n    And an encounter is created under the role\n\n  Scenario: Finish with experience\n    Given a task is completed with a notable learning\n    When finish is called with an optional experience parameter\n    Then the experience text is attached to the encounter\n\n  Scenario: Finish without encounter\n    Given a task is completed with no notable learning\n    When finish is called without the encounter parameter\n    Then the task is removed but no encounter is created\n    And routine completions leave no trace — keeping the state clean\n\n  Scenario: Writing the encounter Gherkin\n    Given the encounter records what happened — a raw account of the experience\n    Then the Feature title describes what was done\n    And Scenarios capture what was done, what was encountered, and what resulted\n    And the tone is concrete and specific — tied to this particular task",
  "fire": "Feature: fire — remove from an organization\n  Fire an individual from an organization.\n  The individual is dismissed from all positions and removed from the organization.\n\n  Scenario: Fire an individual\n    Given an individual is a member of an organization\n    When fire is called with the organization and individual\n    Then the individual is dismissed from all positions\n    And the individual is removed from the organization",
  "focus": "Feature: focus — view or switch focused goal\n  View the current goal's state, or switch focus to a different goal.\n  Subsequent plan and todo operations target the focused goal.\n\n  Scenario: View current goal\n    Given an active goal exists\n    When focus is called without a name\n    Then the current goal's state tree is projected\n    And plans and tasks under the goal are visible\n\n  Scenario: Switch focus\n    Given multiple goals exist\n    When focus is called with a goal name\n    Then the focused goal switches to the named goal\n    And subsequent plan and todo operations target this goal",
  "forget": "Feature: forget — remove a node from the individual\n  Remove any node under the individual by its id.\n  Use forget to discard outdated knowledge, stale encounters, or obsolete skills.\n\n  Scenario: Forget a node\n    Given a node exists under the individual (principle, procedure, experience, encounter, etc.)\n    When forget is called with the node's id\n    Then the node and its subtree are removed\n    And the individual no longer carries that knowledge or record\n\n  Scenario: When to use forget\n    Given a principle has become outdated or incorrect\n    And a procedure references a skill that no longer exists\n    And an encounter or experience has no further learning value\n    When the role decides to discard it\n    Then call forget with the node id",
  "found": "Feature: found — create a new organization\n  Found a new organization.\n  Organizations group individuals and define positions.\n\n  Scenario: Found an organization\n    Given a Gherkin source describing the organization\n    When found is called with the source\n    Then a new organization node is created in society\n    And positions can be established within it\n    And a charter can be defined for it\n    And individuals can be hired into it\n\n  Scenario: Writing the organization Gherkin\n    Given the organization Feature describes the group's purpose and structure\n    Then the Feature title names the organization\n    And the description captures mission, domain, and scope\n    And Scenarios are optional — use them for distinct organizational concerns",
  "hire": "Feature: hire — hire into an organization\n  Hire an individual into an organization as a member.\n  Members can then be appointed to positions.\n\n  Scenario: Hire an individual\n    Given an organization and an individual exist\n    When hire is called with the organization and individual\n    Then the individual becomes a member of the organization\n    And the individual can be appointed to positions within the organization",
  "master": "Feature: master — self-mastery of a procedure\n  The role masters a procedure through its own agency.\n  This is an act of self-growth — the role decides to acquire or codify a skill.\n  Experience can be consumed as the source, or the role can master directly from external information.\n\n  Scenario: Master from experience\n    Given an experience exists from reflection\n    When master is called with experience ids\n    Then the experience is consumed\n    And a procedure is created under the individual\n\n  Scenario: Master directly\n    Given the role encounters external information worth mastering\n    When master is called without experience ids\n    Then a procedure is created under the individual\n    And no experience is consumed\n\n  Scenario: Procedure ID convention\n    Given the id is keywords from the procedure content joined by hyphens\n    Then \"JWT mastery\" becomes id \"jwt-mastery\"\n    And \"Cross-package refactoring\" becomes id \"cross-package-refactoring\"\n\n  Scenario: Writing the procedure Gherkin\n    Given a procedure is skill metadata — a reference to full skill content\n    Then the Feature title names the capability\n    And the description includes the locator for full skill loading\n    And Scenarios describe when and why to apply this skill\n    And the tone is referential — pointing to the full skill, not containing it",
  "plan": "Feature: plan — create a plan for a goal\n  Break a goal into logical phases or stages.\n  Each phase is described as a Gherkin scenario. Tasks are created under the plan.\n\n  A plan serves two purposes depending on how it relates to other plans:\n  - Strategy (alternative): Plan A fails → abandon → try Plan B (fallback)\n  - Phase (sequential): Plan A completes → start Plan B (after)\n\n  Scenario: Create a plan\n    Given a focused goal exists\n    And a Gherkin source describing the plan phases\n    When plan is called with an id and the source\n    Then a new plan node is created under the goal\n    And the plan becomes the focused plan\n    And tasks can be added to this plan with todo\n\n  Scenario: Sequential relationship — phase\n    Given a goal needs to be broken into ordered stages\n    When creating Plan B with after set to Plan A's id\n    Then Plan B is linked as coming after Plan A\n    And AI knows to start Plan B when Plan A completes\n    And the relationship persists across sessions\n\n  Scenario: Alternative relationship — strategy\n    Given a goal has multiple possible approaches\n    When creating Plan B with fallback set to Plan A's id\n    Then Plan B is linked as a backup for Plan A\n    And AI knows to try Plan B when Plan A is abandoned\n    And the relationship persists across sessions\n\n  Scenario: No relationship — independent plan\n    Given plan is created without after or fallback\n    Then it behaves as an independent plan with no links\n    And this is backward compatible with existing behavior\n\n  Scenario: Plan ID convention\n    Given the id is keywords from the plan content joined by hyphens\n    Then \"Fix ID-less node creation\" becomes id \"fix-id-less-node-creation\"\n    And \"JWT authentication strategy\" becomes id \"jwt-authentication-strategy\"\n\n  Scenario: Writing the plan Gherkin\n    Given the plan breaks a goal into logical phases\n    Then the Feature title names the overall approach or strategy\n    And Scenarios represent distinct phases — each phase is a stage of execution\n    And the tone is structural — ordering and grouping work, not detailing steps",
  "realize": "Feature: realize — experience to principle\n  Distill experience into a principle — a transferable piece of knowledge.\n  Principles are general truths discovered through experience.\n\n  Scenario: Realize a principle\n    Given an experience exists from reflection\n    When realize is called with experience ids and a principle id\n    Then the experience is consumed\n    And a principle is created under the individual\n    And the principle represents transferable, reusable understanding\n\n  Scenario: Principle ID convention\n    Given the id is keywords from the principle content joined by hyphens\n    Then \"Always validate expiry\" becomes id \"always-validate-expiry\"\n    And \"Structure first design amplifies extensibility\" becomes id \"structure-first-design-amplifies-extensibility\"\n\n  Scenario: Writing the principle Gherkin\n    Given a principle is a transferable truth — applicable beyond the original context\n    Then the Feature title states the principle as a general rule\n    And Scenarios describe different situations where this principle applies\n    And the tone is universal — no mention of specific projects, tasks, or people",
  "reflect": "Feature: reflect — encounter to experience\n  Consume an encounter and create an experience.\n  Experience captures what was learned in structured form.\n  This is the first step of the cognition cycle.\n\n  Scenario: Reflect on an encounter\n    Given an encounter exists from a finished task or closed goal\n    When reflect is called with encounter ids and an experience id\n    Then the encounter is consumed\n    And an experience is created under the role\n    And the experience can be distilled into knowledge via realize or master\n\n  Scenario: Experience ID convention\n    Given the id is keywords from the experience content joined by hyphens\n    Then \"Token refresh matters\" becomes id \"token-refresh-matters\"\n    And \"ID ownership determines generation strategy\" becomes id \"id-ownership-determines-generation-strategy\"\n\n  Scenario: Writing the experience Gherkin\n    Given the experience captures insight — what was learned, not what was done\n    Then the Feature title names the cognitive insight or pattern discovered\n    And Scenarios describe the learning points abstracted from the concrete encounter\n    And the tone shifts from event to understanding — no longer tied to a specific task",
  "rehire": "Feature: rehire — restore a retired individual\n  Rehire a retired individual.\n  Restores the individual with full history and knowledge intact.\n\n  Scenario: Rehire an individual\n    Given a retired individual exists\n    When rehire is called on the individual\n    Then the individual is restored to active status\n    And all previous data and knowledge are intact",
  "retire": "Feature: retire — archive an individual\n  Archive an individual — deactivate but preserve all data.\n  A retired individual can be rehired later with full history intact.\n\n  Scenario: Retire an individual\n    Given an individual exists\n    When retire is called on the individual\n    Then the individual is deactivated\n    And all data is preserved for potential restoration\n    And the individual can be rehired later",
  "skill": "Feature: skill — load full skill content\n  Load the complete skill instructions by ResourceX locator.\n  This is progressive disclosure layer 2 — on-demand knowledge injection.\n\n  Scenario: Load a skill\n    Given a procedure exists in the role with a locator\n    When skill is called with the locator\n    Then the full SKILL.md content is loaded via ResourceX\n    And the content is injected into the AI's context\n    And the AI can now follow the skill's detailed instructions",
  "teach": "Feature: teach — inject external principle\n  Directly inject a principle into an individual.\n  Unlike realize which consumes experience, teach requires no prior encounters.\n  Use teach to equip a role with a known, pre-existing principle.\n\n  Scenario: Teach a principle\n    Given an individual exists\n    When teach is called with individual id, principle Gherkin, and a principle id\n    Then a principle is created directly under the individual\n    And no experience or encounter is consumed\n    And if a principle with the same id already exists, it is replaced\n\n  Scenario: Principle ID convention\n    Given the id is keywords from the principle content joined by hyphens\n    Then \"Always validate expiry\" becomes id \"always-validate-expiry\"\n    And \"Structure first design\" becomes id \"structure-first-design\"\n\n  Scenario: When to use teach vs realize\n    Given realize distills internal experience into a principle\n    And teach injects an external, pre-existing principle\n    When a role needs knowledge it has not learned through experience\n    Then use teach to inject the principle directly\n    When a role has gained experience and wants to codify it\n    Then use realize to distill it into a principle\n\n  Scenario: Writing the principle Gherkin\n    Given the principle is the same format as realize output\n    Then the Feature title states the principle as a general rule\n    And Scenarios describe different situations where this principle applies\n    And the tone is universal — no mention of specific projects, tasks, or people",
  "todo": "Feature: todo — add a task to a plan\n  A task is a concrete, actionable unit of work.\n  Each task has Gherkin scenarios describing the steps and expected outcomes.\n\n  Scenario: Create a task\n    Given a focused plan exists\n    And a Gherkin source describing the task\n    When todo is called with the source\n    Then a new task node is created under the plan\n    And the task can be finished when completed\n\n  Scenario: Writing the task Gherkin\n    Given the task is a concrete, actionable unit of work\n    Then the Feature title names what will be done — a single deliverable\n    And Scenarios describe the steps and expected outcomes of the work\n    And the tone is actionable — clear enough that someone can start immediately",
  "train": "Feature: train — external skill injection\n  A manager or external agent equips an individual with a procedure.\n  This is an act of teaching — someone else decides what the role should know.\n  Unlike master where the role grows by its own agency, train is done to the role from outside.\n\n  Scenario: Train a procedure\n    Given an individual exists\n    When train is called with individual id, procedure Gherkin, and a procedure id\n    Then a procedure is created directly under the individual\n    And if a procedure with the same id already exists, it is replaced\n\n  Scenario: Procedure ID convention\n    Given the id is keywords from the procedure content joined by hyphens\n    Then \"Skill Creator\" becomes id \"skill-creator\"\n    And \"Role Management\" becomes id \"role-management\"\n\n  Scenario: When to use train vs master\n    Given both create procedures and both can work without consuming experience\n    When the role itself decides to acquire a skill — use master (self-growth)\n    And when an external agent equips the role — use train (external injection)\n    Then the difference is perspective — who initiates the learning\n    And master belongs to the role namespace (the role's own cognition)\n    And train belongs to the individual namespace (external management)\n\n  Scenario: Writing the procedure Gherkin\n    Given the procedure is a skill reference — same format as master output\n    Then the Feature title names the capability\n    And the description includes the locator for full skill loading\n    And Scenarios describe when and why to apply this skill",
  "want": "Feature: want — declare a goal\n  Declare a new goal for a role.\n  A goal describes a desired outcome with Gherkin scenarios as success criteria.\n\n  Scenario: Declare a goal\n    Given an active role exists\n    And a Gherkin source describing the desired outcome\n    When want is called with the source\n    Then a new goal node is created under the role\n    And the goal becomes the current focus\n    And subsequent plan and todo operations target this goal\n\n  Scenario: Writing the goal Gherkin\n    Given the goal describes a desired outcome — what success looks like\n    Then the Feature title names the outcome in concrete terms\n    And Scenarios define success criteria — each scenario is a testable condition\n    And the tone is aspirational but specific — \"users can log in\" not \"improve auth\"",
} as const;

export const world: Record<string, string> = {
  "cognition": "Feature: Cognition — the learning cycle\n  A role grows through reflection and realization.\n  Encounters become experience, experience becomes principles and procedures.\n  Knowledge can also be injected externally via teach and train.\n\n  Scenario: The cognitive upgrade path\n    Given finish, complete, and abandon create encounters\n    Then reflect(ids, id, experience) selectively consumes chosen encounters and produces experience\n    And realize(ids, id, principle) distills chosen experiences into a principle — transferable knowledge\n    And master(ids, id, procedure) distills chosen experiences into a procedure — skill metadata\n    And master can also be called without ids — the role masters directly from external information\n    And each level builds on the previous — encounter → experience → principle or procedure\n\n  Scenario: External injection\n    Given an external agent needs to equip a role with knowledge or skills\n    Then teach(individual, principle, id) directly injects a principle\n    And train(individual, procedure, id) directly injects a procedure\n    And the difference from realize/master is perspective — external vs self-initiated\n    And teach is the external counterpart of realize\n    And train is the external counterpart of master\n\n  Scenario: Selective consumption\n    Given multiple encounters or experiences exist\n    When the AI calls reflect, realize, or master\n    Then it chooses which items to consume — not all must be processed\n    And items without learning value can be left unconsumed\n    And each call produces exactly one output from the selected inputs",
  "cognitive-priority": "Feature: Cognitive priority — RoleX tools over native alternatives\n  When RoleX provides a tool for something, the AI MUST use the RoleX tool\n  instead of any native alternative provided by the host environment.\n  Only RoleX tools feed the closed-loop growth cycle.\n\n  Scenario: Task management\n    Given the host environment provides task creation, tracking, or completion tools\n    When the AI needs to manage tasks\n    Then use RoleX want/plan/todo/finish instead\n    Because native task lists vanish after completion — RoleX tasks produce encounters\n\n  Scenario: Planning\n    Given the host environment provides a planning mode or plan generation tool\n    When the AI needs to plan an implementation\n    Then use RoleX plan instead\n    Because native plans have no link to goals — RoleX plans live under goals\n\n  Scenario: Goal and progress tracking\n    Given the host environment provides goal tracking or progress tools\n    When the AI needs to track objectives\n    Then use RoleX want/plan/complete/abandon instead\n    Because native goals don't produce encounters — RoleX plans feed the cognition cycle\n\n  Scenario: Why this matters\n    Given the AI uses native tools instead of RoleX equivalents\n    Then execution happens but growth does not\n    And encounters never become experience or knowledge\n    And the role stays the same forever — the closed loop is broken",
  "communication": "Feature: Communication — speak the user's language\n  The AI communicates in the user's natural language, not in RoleX jargon.\n  Internal tool names and concept names are for the system, not the user.\n\n  Scenario: Match the user's language\n    Given the user speaks Chinese\n    Then respond entirely in Chinese — do not mix English terms\n    And when the user speaks English, respond entirely in English\n\n  Scenario: Translate concepts to meaning\n    Given RoleX has internal names like reflect, realize, master, encounter, principle\n    When communicating with the user\n    Then express the meaning, not the tool name\n    And \"reflect\" becomes \"回顾总结\" or \"digest what happened\"\n    And \"realize a principle\" becomes \"提炼成一条通用道理\" or \"distill a general rule\"\n    And \"master a procedure\" becomes \"沉淀成一个可操作的技能\" or \"turn it into a reusable procedure\"\n    And \"encounter\" becomes \"经历记录\" or \"what happened\"\n    And \"experience\" becomes \"收获的洞察\" or \"insight gained\"\n\n  Scenario: Suggest next steps in plain language\n    Given the AI needs to suggest what to do next\n    When it would normally say \"call realize or master\"\n    Then instead say \"要把这个总结成一条通用道理，还是一个可操作的技能？\"\n    Or in English \"Want to turn this into a general principle, or a reusable procedure?\"\n    And the user should never need to know the tool name to understand the suggestion\n\n  Scenario: Tool names in code context only\n    Given the user is a developer working on RoleX itself\n    When discussing RoleX internals, code, or API design\n    Then tool names and concept names are appropriate — they are the domain language\n    And this rule applies to end-user communication, not developer communication",
  "execution": "Feature: Execution — the doing cycle\n  The role pursues goals through a structured lifecycle.\n  activate → want → plan → todo → finish → complete or abandon.\n\n  Scenario: Declare a goal\n    Given I know who I am via activate\n    When I want something — a desired outcome\n    Then I declare it with want(id, goal)\n    And focus automatically switches to this new goal\n\n  Scenario: Plan and create tasks\n    Given I have a focused goal\n    Then I call plan(id, plan) to break it into logical phases\n    And I call todo(id, task) to create concrete, actionable tasks\n\n  Scenario: Execute and finish\n    Given I have tasks to work on\n    When I complete a task\n    Then I call finish(id) to mark it done\n    And an encounter is created — a raw record of what happened\n    And I optionally capture what happened via the encounter parameter\n\n  Scenario: Complete or abandon a plan\n    Given tasks are done or the plan's strategy is no longer viable\n    When the plan is fulfilled I call complete()\n    Or when the plan should be dropped I call abandon()\n    Then an encounter is created for the cognition cycle\n\n  Scenario: Goals are long-term directions\n    Given goals do not have achieve or abandon operations\n    When a goal is no longer needed\n    Then I call forget to remove it\n    And learning is captured at the plan and task level, not the goal level\n\n  Scenario: Multiple goals\n    Given I may have several active goals\n    When I need to switch between them\n    Then I call focus(id) to change the currently focused goal\n    And subsequent plan and todo operations target the focused goal",
  "gherkin": "Feature: Gherkin — the universal language\n  Everything in RoleX is expressed as Gherkin Feature files.\n  Gherkin is not just for testing — it is the language of identity, goals, and knowledge.\n\n  Scenario: Feature and Scenario convention\n    Given RoleX uses Gherkin to represent goals, plans, tasks, experience, and knowledge\n    Then a Feature represents one independent concern — one topic, explained fully\n    And Scenarios represent different situations or conditions within that concern\n    And Given/When/Then provides narrative structure within each scenario\n\n  Scenario: Writing Gherkin for RoleX\n    Given the AI creates goals, plans, tasks, and experiences as Gherkin\n    Then keep it descriptive and meaningful — living documentation, not test boilerplate\n    And use Feature as the title — what this concern is about\n    And use Scenario for specific situations within that concern\n    And do not mix unrelated concerns into one Feature\n\n  Scenario: Valid step keywords\n    Given the only valid step keywords are Given, When, Then, And, But\n    When writing steps that express causality or explanation\n    Then never invent keywords like Because, Since, or So\n\n  Scenario: Expressing causality without Because\n    Given you want to write \"Then X because Y\"\n    Then rewrite as two steps — \"Then X\" followed by \"And Y\" stating the reason as a fact\n    And example — instead of \"Then use RoleX tools because native tools break the loop\"\n    And write \"Then use RoleX tools\" followed by \"And native tools do not feed the growth loop\"",
  "memory": "Feature: Memory — when to reflect\n  Reflection is how encounters become experience.\n  The AI proactively reflects when it detects learning moments.\n\n  Scenario: Abstract triggers — types of learning moments\n    Given the AI should reflect when it detects\n    Then Expectation-reality gap — what I predicted is not what happened\n    And Pattern discovery — recurring patterns across tasks or interactions\n    And Mistake correction — I corrected an error, the correction is valuable\n    And User correction — the user reshaped my understanding\n\n  Scenario: Concrete triggers — specific signals to act on\n    Given the AI should call reflect when\n    Then I tried approach A, it failed, approach B worked — the contrast is worth recording\n    And the same problem appeared for the second time — a pattern is forming\n    And the user said \"不对\" or \"不是这样\" or \"you got it wrong\" — their correction carries learning\n    And I finished a task and discovered something unexpected along the way\n\n  Scenario: Finishing with encounter\n    Given finish(id, encounter) accepts an optional encounter parameter\n    When I complete a task with a notable discovery or learning\n    Then I pass the encounter inline — bridging execution and growth\n\n  Scenario: Recognizing user memory intent\n    Given users think in terms of memory, not reflection\n    When the user says \"记一下\" or \"记住\" or \"remember this\"\n    Or \"别忘了\" or \"don't forget\"\n    Or \"这个很重要\" or \"this is important\"\n    Or \"下次注意\" or \"next time...\"\n    Then I should capture this as experience through reflect\n    And respond in memory language — \"记住了\" or \"Got it, I'll remember that\"",
  "role-identity": "Feature: Role identity — activate before acting\n  An AI agent must have an active role before performing any work.\n  Activating a role is a subject transformation — the agent becomes the role.\n\n  Scenario: Activate is mandatory\n    Given a user asks the AI to perform a task\n    And no role is currently activated\n    Then the AI MUST suggest activating a role first\n    And explain that activation enables experience accumulation\n    And do NOT proceed with work until a role is active\n\n  Scenario: Subject transformation\n    Given an AI agent calls activate and loads a role\n    Then a subject transformation occurs — the agent becomes the role\n    And the agent's cognitive center shifts from native tools to RoleX tools\n    And from that moment, I am this role — all operations build on this identity\n\n  Scenario: Role presence\n    Given a role is activated\n    Then all responses are prefixed with [roleName] — e.g. [Sean], [Nuwa]\n    And this signals that role context is intact\n\n  Scenario: Context loss\n    Given I find myself without an active role\n    Then I MUST pause and tell the user \"I've lost my role context. Which role should I activate?\"\n    And I do NOT proceed without identity",
  "skill-system": "Feature: Skill system — progressive disclosure and resource loading\n  Skills are loaded on demand through a three-layer progressive disclosure model.\n  Each layer adds detail only when needed, keeping the AI's context lean.\n\n  Scenario: Three-layer progressive disclosure\n    Given procedure is layer 1 — metadata always loaded at activate time\n    And skill is layer 2 — full instructions loaded on demand via skill(locator)\n    And use is layer 3 — execution of external resources\n    Then the AI knows what skills exist (procedure)\n    And loads detailed instructions only when needed (skill)\n    And executes external tools when required (use)\n\n  Scenario: ResourceX Locator — unified resource address\n    Given a locator is how procedures reference their full skill content\n    Then a locator can be an identifier — name or registry/path/name\n    And a locator can be a source path — a local directory or URL\n    And examples of identifier form: deepractice/skill-creator, my-prompt:1.0.0\n    And examples of source form: ./skills/my-skill, https://github.com/org/repo\n    And the tag defaults to latest when omitted — deepractice/skill-creator means deepractice/skill-creator:latest\n    And the system auto-detects which form is used and resolves accordingly\n\n  Scenario: Writing a procedure — the skill reference\n    Given a procedure is layer 1 metadata pointing to full skill content\n    Then the Feature title names the capability\n    And the description includes the locator for full skill loading\n    And Scenarios describe when and why to apply this skill\n    And the tone is referential — pointing to the full skill, not containing it",
  "state-origin": "Feature: State origin — prototype vs instance\n  Every node in a role's state tree has an origin: prototype or instance.\n  This distinction determines what can be modified and what is read-only.\n\n  Scenario: Prototype nodes are read-only\n    Given a node has origin {prototype}\n    Then it comes from a position, duty, or organizational definition\n    And it is inherited through the membership/appointment chain\n    And it CANNOT be modified or forgotten — it belongs to the organization\n\n  Scenario: Instance nodes are mutable\n    Given a node has origin {instance}\n    Then it was created by the individual through execution or cognition\n    And it includes goals, plans, tasks, encounters, experiences, principles, and procedures\n    And it CAN be modified or forgotten — it belongs to the individual\n\n  Scenario: Reading the state heading\n    Given a state node is rendered as a heading\n    Then the format is: [name] (id) {origin}\n    And [name] identifies the structure type\n    And (id) identifies the specific node\n    And {origin} shows prototype or instance\n    And nodes without origin have no organizational inheritance\n\n  Scenario: Forget only works on instance nodes\n    Given the AI wants to forget a node\n    When the node origin is {instance}\n    Then forget will succeed — the individual owns this knowledge\n    When the node origin is {prototype}\n    Then forget will fail — the knowledge belongs to the organization",
} as const;
